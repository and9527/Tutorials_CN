module flinkcdc

loadModule("plugins::EncoderDecoder");
go;

def obj2str(data){
	if(data.form()==PAIR){
		datastr=string(data);
	}else if(data.form()!=SCALAR&&data.form()!=MATRIX){
		datastr=toStdJson(data);
	}else{
		datastr=string(data);
	}
	if(datastr.size()>1){
		datastr=concat(datastr," ");
	}
	return datastr;
}

def writeError(errorInfo,data=NULL,beforeData=NULL){
	try{
		msg="FKCDC: "+errorInfo;
		if(isVoid(data)==false){
			datastr=obj2str(data);
			//datastr=substr(datastr,0,65535);
			msg+=" data: "+datastr;
		}
		if(beforeData.isVoid()==false){
			datastr=obj2str(beforeData);
			//datastr=substr(datastr,0,65535);
			msg+=" beforeData: "+datastr;
		}
		print(string(now())+":"+msg);
		writeLog(msg);
	}catch(ex){
		print("writeError error "+obj2str(ex)+", data:");
		print(data);
	}
}

def parseJsonData(parseSchema,data){
    if(defined("parseJsonTable",DEF)){
        rawTable=parseJsonTable(data,parseSchema);
    }else{
        coder = EncoderDecoder::jsonDecoder(parseSchema.name, parseSchema.typeInt);
        rawTable=coder.parse(string(data));
	}
	return rawTable;
}

def setTableErrorMsg(mutable invalidIndex2MsgTable,index,errorTable,errorType,errorMsg){
	if(index.size()<1)
		return;
	size=index.size();
	if(errorTable.size()==1){
		insert into invalidIndex2MsgTable values(index as index,take(errorTable,size) as table,take(errorType,size) as type,
									take(errorMsg,size) as msg,take(now(true),size) as time);
	}else{
		if(errorTable.size()!=index.size()){
			error="setTableErrorMsg errorTable size "+string(errorTable.size())+" mismatch index size "+string(index.size());
			writeError(error);
			throw error;
		}
		insert into invalidIndex2MsgTable values(index as index,errorTable as table,take(errorType,size) as type,
									take(errorMsg,size) as msg,take(now(true),size) as time);
	}
}

def setTablesErrorMsg(mutable invalidIndex2MsgTable,index,tables,type,msg){
	if(tables.size()!=index.size()){
		error="setTablesErrorMsg tables size "+string(tables.size())+" mismatch index size "+string(index.size());
		writeError(error);
		throw error;
	}
	indexTable=table(index as index,tables as table);
	indexTable.clear!();
	tableArray=tables.split(",");
	addIndex=def(mutable indexTable,index,tables){
		for(table in tables)
			indexTable.tableInsert((index,table));
		return tables.size();
	}
	loop(addIndex{indexTable},index,tableArray);
	tableArray.sortBy!("index");
	setTableErrorMsg(invalidIndex2MsgTable,tableArray.index,tableArray.table,type,msg);
	return index.size();
}

def data2DdbtableIndex(sourceTableConfigDict,ddbTableDict,tableArray,mutable index2DataDict,mutable invalidIndex2MsgTable,index,type,data){
	stage="prepare";
	rawTable=NULL;
	try{
		if(index.size()<1)
			return 0;
		if(isVoid(sourceTableConfigDict.schema)==false){
			stage="parseSourceTableJson";
			rawTable=parseJsonData(sourceTableConfigDict.schema,data);
		}
	}catch(ex){
		msg=sourceTableConfigDict.name+" in "+stage+" error: "+obj2str(ex);
		//invalidIndex2MsgTable[index]=msg;
		loop(setTableErrorMsg{invalidIndex2MsgTable,index,,"parseJson",msg},tableArray);
		writeError(msg);
		return 0;
	}
	sum=0;
	tableConfigDict=sourceTableConfigDict.table;
	for(ddbTableName in tableArray){
		try{
			stage="getConfig";
			tableConfig=tableConfigDict[ddbTableName];
			if(tableConfig.isVoid()){
				throw "no config";
			}
			if(rawTable.isVoid()){
				//parse with ddb table schema
				stage="parseDdbTableJson";
				tableRawData=parseJsonData(ddbTableDict[ddbTableName].schema,data);
			}else{
				tableRawData=rawTable;
			}
			stage="transform";
			if(isVoid(tableConfig.transform)==false)
				ddbTable=call(tableConfig.transform,tableRawData);
			else
				ddbTable=tableRawData;
			
			stage="setIndex";
			indexTypeDict=dict(STRING,ANY);
			indexTypeDict["index"]=index;
			indexTypeDict["type"]=type;
			indexTypeDict["ddbTable"]=ddbTable;
			if(index2DataDict[ddbTableName].isVoid()){
				prevResult=();
			}else{
				prevResult=index2DataDict[ddbTableName];
			}
			prevResult.append!(indexTypeDict);
			index2DataDict[ddbTableName]=prevResult;
			sum+=index.size();
		}catch(ex){
			msg=sourceTableConfigDict.name+"."+ddbTableName+" in "+stage+" error: "+obj2str(ex);
			//invalidIndex2MsgTable[index]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,index,ddbTableName,"transform",msg);
			writeError(msg);
		}
	}
	return sum;
}

def isInTransation(msg){
	return msg.strpos("<ChunkInTransaction>") >= 0;
}

def opAppendTable(mutable tableHandle,tableName,mutable invalidIndex2MsgTable,data,index){
	times=0;
	//FIXME
	// if(data.columnNames().find("isDeleted")>=0){
	// 	writeError(tableName+" opAppendTable delete "+obj2str(eachAt(data.BizIndex,data["isDeleted"]!=NULL&&data["isDeleted"]!=0)));
	// 	writeError(tableName+" opAppendTable add "+obj2str(eachAt(data.BizIndex,data["isDeleted"]==NULL||data["isDeleted"]==0)));
	// }else{
	// 	writeError(tableName+" opAppendTable add "+obj2str(data.BizIndex));
	// }
	do{
		try{
			times+=1;
			size=tableHandle.tableInsert(data);
			if(size!=data.size()){
				msg=tableName+" opAppendTable append size "+string(size)+" mismatch "+string(data.size());
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableName,"append",msg);
				writeError(msg);
				return 0;
			}
			break;
		}catch(ex){
			msg=obj2str(ex);
			if(times > 10 || isInTransation(msg)==false){
				msg=tableName+" opAppendTable append error "+msg;
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableName,"append",msg);
				writeError(msg);
				return 0;
			}
			sleep(100);
			writeError(tableName+" opAppendTable failed, retry times "+string(times)+" error: "+msg);
		}
	}while(true);
	return data.size();
}

//按照uniqueColumns的顺序获取条件，执行速度更快，col方法不支持向量，必须循环一次
def getRowWhereCode(uniqueColumns,data,rowIndex){
	eqCodes=loop(expr{,==,},sqlCol(uniqueColumns.name),data[rowIndex].values()[uniqueColumns.index]);
	if(eqCodes.size()==1)
		return eqCodes[0];
	return unifiedExpr(eqCodes,take(and,eqCodes.size()-1));
}

def getDataInParCode(parCols,data){
	if(parCols.isVoid())
		return NULL;
	inCodes=();
	for(colName in parCols){
		colValues=set(data[colName]).keys();
		colValues=colValues[colValues!=NULL];
		if(colValues.size()<1)
			continue;
		inCodes.append!(expr(sqlCol(colName),in,colValues));
	}
	if(inCodes.size()<1)
		return NULL;
	if(inCodes.size()==1)
		return inCodes[0];
	return unifiedExpr(inCodes,take(and,inCodes.size()-1));
}

def getPartitionValue(ptypeName,pschema,value){
	/*
	index=0;
	ptypeName=schema.partitionTypeName[index];
	pschema=schema.partitionSchema[index];
	pcolumnName=schema.partitionColumnName[index];
	*/
	if(ptypeName=="VALUE"){
		return cast(value,pschema.type());
	}else if(ptypeName=="HASH"){
		//schema=12
		return hashBucket(value,pschema);
	}else if(ptypeName=="RANGE"){
		//schema=[0,5,10]
		return asof(pschema,cast(value,pschema.type()));
	}else{
		throw "getPartitionValue error, unknow partition type "+ptypeName;
	}
}

def push(mutable tuple,value){
	valueInt=int(version().split(" ")[0].split("."))[0:4].nullFill(0);
	diff=valueInt-[2,0,10,1];
	cmp=def(a,b){
		if(a!=0){
			return a;
		}
		return b;
	}
	result=reduce(cmp,diff,0);
	if(result>=0){
		tuple.append!(enlist(value));
	}else{
		tuple.append!(value);
	}
}

def getDistinctPartitionValue(ptypeName,pschema,value){
	partitionValues=getPartitionValue(ptypeName,pschema,value);
	partitionStrs=string(partitionValues);
	partitionDict=dict(STRING,partitionValues.type());
	partitionDict[partitionStrs]=partitionValues;
	return partitionDict.values();
}

def opDeleteTable(tableConfig,mutable tableHandle,mutable invalidIndex2MsgTable,data,index){
	stage="start";
	try{
		stage="getRowWhereCode";
		whereCodes=loop(getRowWhereCode{tableConfig.uniqueColumns,data},0..(data.size()-1));
		if(whereCodes.size()>1)
			delCodes=unifiedExpr(whereCodes,take(or,whereCodes.size()-1));
		else
			delCodes=whereCodes[0];
		if(tableConfig.parCols.isVoid()==false){
			stage="getPartitionValue";
			if(tableConfig.parCols.size()>1){
				partitionValues=loop(getDistinctPartitionValue,tableConfig.parTypes,tableConfig.parSchemas,data[tableConfig.parCols]);
			}else{
				partitionValues=push(array(ANY),getPartitionValue(tableConfig.parTypes,tableConfig.parSchemas,data[tableConfig.parCols]));
			}
			if(partitionValues.isVoid()==false){
				stage="partitionIn";
				parColInCodes=loop(makeCall{partition},sqlCol(tableConfig.parCols),partitionValues);
				if(parColInCodes.size()>1)
					parColInAndCodes=unifiedExpr(parColInCodes,take(and,parColInCodes.size()-1));
				else
					parColInAndCodes=parColInCodes[0];
				delCodes=expr(parColInAndCodes,and,delCodes);
			}
		}
	}catch(ex){
		msg=tableConfig.name+" opDeleteTable prepare delete code error "+obj2str(ex);
		//invalidIndex2MsgTable[index]=msg;
		setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"prepareDelete",msg);
		writeError(msg);
		return 0;
	}
	//FIXME
	delValues=NULL;
	// try{
	// 	delValues=sql(sqlCol("*"),tableHandle,where=delCodes).eval();
	// 	writeError(tableName+" opDeleteTable.delete "+obj2str(delValues.BizIndex));
	// }catch(ex){
	// 	writeError(tableName+" opDeleteTable.sql "+string(delCodes),ex);
	// }
	times=0;
	do{
		try{
			times+=1;
			delCount=sqlDelete(tableHandle,delCodes).eval();
			//writeError(tableName+" opDeleteTable.sqlDelete size "+string(delCount)+" delCode "+string(delCodes));
			if(delCount!=data.size()){
				msg=tableConfig.name+" opDeleteTable delete size "+string(delCount)+" mismatch "+string(data.size())+"\nsql: "+obj2str(delCodes)+"\nvalues: "+obj2str(delValues);
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"delete",msg);
				writeError(msg.substr(0,125));
				return 0;
			}
			break;
		}catch(ex){
			msg=obj2str(ex);
			if(times > 10 || isInTransation(msg)==false){
				msg=tableConfig.name+" opDeleteTable delete error code "+string(delCodes)+" times "+string(times)+" error: "+msg;
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"delete",msg);
				writeError(msg);
				return 0;
			}
			sleep(100);
			writeError(tableConfig.name+" opDeleteTable failed, retry times "+string(times)+" error: "+msg);
		}
	}while(true);
	return data.size();
}

def addTableOp(mutable lastOpData,mutable tableHandle,mutable invalidIndex2MsgTable,tableConfig,op=NULL,data=NULL,index=NULL){
	if(data.size()!=index.size()){
		msg=" addTableOp op:"+op+" error: data and index "+string(data.size())+" mismatch "+string(index.size());
		//invalidIndex2MsgTable[index]=msg;
		throw msg;
	}
	if(lastOpData.size()==0){
		if(op.isVoid())
			return;
		push(lastOpData,op);
		push(lastOpData,data);
		push(lastOpData,index);
		return;
	}
	if(lastOpData[0]==op){
		push(lastOpData,data);
		push(lastOpData,index);
	}else{
		lastOp=lastOpData[0];
		sumData=lastOpData[1];
		sumIndex=lastOpData[2];
		opIndex=3;
		do{
			if(opIndex>=lastOpData.size())
				break;
			lastSize=sumData.size();
			size=sumData.tableInsert(lastOpData[opIndex]);
			if(size!=lastOpData[opIndex].size()){
				msg=string(size)+" mismatch "+string(lastOpData[opIndex].size());
				setTableErrorMsg(invalidIndex2MsgTable,lastOpData[opIndex+1],tableConfig.name,"append",msg);
				sqlDelete(sumData,expr(makeCall(rowNo,sqlCol(sumData.columnNames()[0])),>=,lastSize)).eval();
			}else{
				sumIndex.append!(lastOpData[opIndex+1]);
			}
			opIndex+=2;
		}while(true);
		lastOpData.clear!();
		if(op.isVoid()==false){
			push(lastOpData,op);
			push(lastOpData,data);
			push(lastOpData,index);
		}
		if(sumData.size()<1)
			return;
		try{
			if(lastOp=='c'){//append
				opAppendTable(tableHandle,tableConfig.name,invalidIndex2MsgTable,sumData,sumIndex);
			}else if(lastOp=='d'){//delete
				opDeleteTable(tableConfig,tableHandle,invalidIndex2MsgTable,sumData,sumIndex);
			}else{
				throw "unknow lastOp "+lastOp;
			}
		}catch(ex){
			msg=tableConfig.name+" addTableOp do op "+string(lastOp)+" error: "+obj2str(ex);
			//invalidIndex2MsgTable[sumIndex]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,sumIndex,tableConfig.name,"process",msg);
			writeError(msg);
			return;
		}
	}
}

def removeNullRows(tableConfig,mutable data,mutable invalidIndex2MsgTable,index){
	if(tableConfig.parCols.isVoid()==false){
		stage="checkParCols";
		nullRows=(data[tableConfig.parCols]==NULL).rowOr();
		if(sum(nullRows)>0){//存在分区列为空的数据，需要写入错误信息里
			nullData=data[nullRows];
			notNullRows=!nullRows;
			data=data[notNullRows];
			msg=tableConfig.name+"存在分区列为空的数据 "+string(nullData.size())+"/"+string(data.size())+","+string(nullData[0]);
			//invalidIndex2MsgTable[index[nullRows]]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,index[nullRows],tableConfig.name,"nullPartition",msg);
			writeError(msg);//,nullData);
			return index[notNullRows];
		}
	}
	return index;
}

def processDataIndex(tableConfig,mutable tableHandle,ddbTable,ddbTableBefore,index2indexintableDictBefore,
						mutable invalidIndex2MsgTable,mutable lastOpData,type,
						index,indexInTableIndex){
	tableName=tableConfig.name;
	stage="prepare";
	data=NULL;
	beforeData=NULL;
	try{
		if(index.size()<1)
			return 0;
		data=ddbTable.slice(indexInTableIndex);
		if(isVoid(data)||data.size()!=index.size()){
			msg=tableName+"找不到对应的数据，预期"+string(index.size())+"，只找到"+string(data.size());
			//invalidIndex2MsgTable[index]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
			writeError(msg);
			return 0;
		}
	}catch(ex){
		msg="processDataIndex "+tableName+" in "+stage+" error: "+obj2str(ex);
		//invalidIndex2MsgTable[index]=msg;
		setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
		writeError(msg);
		return 0;
	}
	try{
		//检查分区列
		delFieldDict=tableConfig.delFieldDict;
		if(type=='u'){//update
			stage="updateBefore";
			//获取修改前的数据，应该是一一对应的
			beforeDataIndex=index2indexintableDictBefore[index];
			if(isVoid(beforeDataIndex)||beforeDataIndex.count()!=index.size()){
				msg=tableName+"找不到修改前的索引，预期"+string(index.size())+"，只找到"+string(beforeDataIndex.count());
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
				writeError(msg);
				return 0;
			}
			if(beforeDataIndex.form()==SCALAR){
				beforeDataIndex=enlist(beforeDataIndex);
			}
			beforeData=ddbTableBefore.slice(beforeDataIndex);
			if(isVoid(beforeData)||beforeData.size()!=index.size()){
				msg=tableName+"找不到修改前的数据，预期"+string(index.size())+"，只找到"+string(beforeData.size());
				//invalidIndex2MsgTable[index]=msg;
				setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
				writeError(msg);
				return 0;
			}
			//以下填充代码在当前逻辑中总是有问题
			// nullres=isNull(beforeData);
			// beforeDataFilledCols=loop(nullFill,beforeData.values(),data.values());
			// beforeDataFilled=table(beforeDataFilledCols);
			// beforeDataFilled.rename!(beforeData.columnNames());
			// beforeData=beforeDataFilled;
			//使用data填充beforeData的空值
			if(delFieldDict.isVoid()==false){//软删除，只需要添加即可，会自动去重
				data[delFieldDict.name]=delFieldDict.value[0];//添加没删除标记
				//是否有设置keyCols，分区列和排序列
				expendedIndex=index;
				if(tableConfig.keyCols.isVoid()==false){
					stage="updateDCheckChanged";
					keyChangedRows=each(!=,data[tableConfig.keyCols],beforeData[tableConfig.keyCols]).rowOr();
					if(keyChangedRows.sum()>0){//有keyCol变化，需要手动添加一条删除记录在前面
						stage="updateDAppendDelete";
						keyChangedBeforeData=beforeData[keyChangedRows];
						keyChangedBeforeIndex=index[keyChangedRows];
						//需要保证删除和添加有序，添加排序列，确保不会和其他列重复
						indexKey="FlkcdcIndex__";
						update!(data,indexKey,index*2);//添加排序列
						keyChangedBeforeData[delFieldDict.name]=delFieldDict.value[1];//设置软删除
						update!(keyChangedBeforeData,indexKey,(keyChangedBeforeIndex*2)-1);//添加排序列
						data.append!(keyChangedBeforeData);//添加删除记录
						data.sortBy!(indexKey);//排序
						expendedIndex=(data[indexKey]+1)/2;//获取实际的Index
						data.dropColumns!(indexKey);//删除排序列
					}
				}
				//删除为空的数据
				notNullIndex=removeNullRows(tableConfig,data,invalidIndex2MsgTable,expendedIndex);
				if(data.size()<1)
					return 0;
				stage="updateDAppend";
				//opAppendTable(tableHandle,data);
				addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'c',data,notNullIndex);
			}else{//硬删除
				if(tableConfig.parCols.isVoid()==false){
					nullRows=(data[tableConfig.parCols]==NULL).rowOr();
					beforeNullRows=(beforeData[tableConfig.parCols]==NULL).rowOr();
				}else{
					nullRows=take(false,data.size());
					beforeNullRows=take(false,data.size());
				}
				//更新的过程是先添加新的，然后删除旧的。
				//如果一个元素被连续更新，则只有最后一次更新有效，所以需要检测每次更新的键值是否重复
				stage="updateHPrepare";
				value2appendId=dict(BLOB,LONG);
				colDefs=data.schema().colDefs;
				delData=table(data.size():0,colDefs.name,colDefs.typeInt);
				delIndex=array(INT);
				appendIdName="FlkcdcAppendID__";
				appendIndexName="FlkcdcAppendIndex__";
				appendId=0;
				appendDataNames=colDefs.name;
				appendDataTypes=colDefs.typeInt;
				appendDataNames.append!(appendIdName);
				appendDataTypes.append!(LONG);
				appendDataNames.append!(appendIndexName);
				appendDataTypes.append!(INT);
				appendData=table(data.size():0,appendDataNames,appendDataTypes);
				delAppendId=array(LONG);
				for(i in 0..(data.size()-1)){
					//添加元素
					stage="updateHData "+i;
					if(nullRows[i]==false){//分区列为空的值不用添加
						dataDict=data[i];
						if(tableConfig.uniqueColumns.name.size()>1)
						    key=unifiedCall(makeKey,dataDict[tableConfig.uniqueColumns.name]);
						else
						    key=string(dataDict[tableConfig.uniqueColumns.name]);
						appendValue=dataDict.values();
						appendId+=1;
						appendValue.append!(appendId);
						appendValue.append!(index[i]);
						appendData.tableInsert(appendValue);
						addAppendId=true;
					}else
						addAppendId=false;
					//删除旧的元素
					if(beforeNullRows[i]==false){//分区列为空的值不用删除
						beforeDataDict=beforeData[i];
						if(tableConfig.uniqueColumns.name.size()>1)
    						beforeKey=unifiedCall(makeKey,beforeDataDict[tableConfig.uniqueColumns.name]);
    					else
    					    beforeKey=string(beforeDataDict[tableConfig.uniqueColumns.name]);
						lastId=value2appendId[beforeKey];
						if(lastId.isNull()==false){//存在，即还没执行，不需要删除
							delAppendId.append!(lastId);
							value2appendId.erase!(beforeKey);
						}else{//不存在，也就是还在磁盘上，需要删除
							delData.tableInsert(beforeDataDict.values());
							delIndex.append!(index[i]);
						}
					}
					if(addAppendId)
						value2appendId[key]=appendId;
				}
				if(delData.size()>0){//删除之前在磁盘上的数据，这些数据不一定存在
					stage="updateHDelete";
					try{
						//opDeleteTable(tableConfig.parCols,tableConfig.uniqueColumns,tableHandle,delData);
						addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'d',delData,delIndex);
					}catch(ex){
						writeError("processDataIndex "+tableName+" in "+stage+" error: "+obj2str(ex));
					}
				}
				if(appendData.size()>0){
					if(delAppendId.size()>0){
						delCode=expr(sqlCol(appendIdName),in,delAppendId);
						sqlDelete(appendData,delCode).eval();
					}
					appendIndex=appendData[appendIndexName];
					appendData.dropColumns!(appendIndexName);
					appendData.dropColumns!(appendIdName);
					stage="updateHAppend";
					//opAppendTable(tableHandle,appendData)
					addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'c',appendData,appendIndex);
				}
			}
		}
		else if(type=='c'){//append
			stage="appendRemoveNullRow";
			notNullIndex=removeNullRows(tableConfig,data,invalidIndex2MsgTable,index);
			if(data.size()<1)
				return 0;
			stage="append";
			if(delFieldDict.isVoid()==false)
				data[delFieldDict.name]=delFieldDict.value[0];
			//opAppendTable(tableHandle,data);
			addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'c',data,notNullIndex);
		}else if(type=='d'){//delete
			stage="deleteRemoveNullRow";
			notNullIndex=removeNullRows(tableConfig,data,invalidIndex2MsgTable,index);
			if(data.size()<1)
				return 0;
			stage="delete";
			if(delFieldDict.isVoid()==false){
				data[delFieldDict.name]=delFieldDict.value[1];
				//opAppendTable(tableHandle,data);
				addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'c',data,notNullIndex);
			}else{
				//opDeleteTable(tableConfig.parCols,tableConfig.uniqueColumns,tableHandle,data);
				addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig,'d',data,notNullIndex);
			}
		}else{
			msg="unknow operation type "+type+" "+tableName;
			//invalidIndex2MsgTable[index]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
			writeError(msg);
			return 0;
		}
		return index.size();
	}catch(ex){
		msg="processDataIndex "+tableName+" in "+stage+" error: "+obj2str(ex);
		//invalidIndex2MsgTable[index]=msg;
		setTableErrorMsg(invalidIndex2MsgTable,index,tableConfig.name,"process",msg);
		writeError(msg);
		return 0;
	}
}

def data2Ddbtable(sourceTableConfigDict,ddbTableDict,tables,mutable index2DataDict,mutable index2BeforedataDict,mutable invalidIndex2MsgTable,
				index,type,data,beforeData){
	try{
		if(type.size()<1)
			return 0;
		tableArray=tables.split(",");
		
		indexTypeDataTable=table(index as index,type as type,data as data,beforeData as beforeData);
		dataSum=select data2DdbtableIndex(sourceTableConfigDict,ddbTableDict,tableArray,index2DataDict,invalidIndex2MsgTable,index,type,data) as count from indexTypeDataTable where data!=NULL;
		beforedataSum=select data2DdbtableIndex(sourceTableConfigDict,ddbTableDict,tableArray,index2BeforedataDict,invalidIndex2MsgTable,index,type,beforeData) as count from indexTypeDataTable where beforeData!=NULL;

		return sum(dataSum.count);
	}catch(ex){
		writeError("processData "+sourceTableConfigDict.name+" error "+obj2str(ex));
		return 0;
	}
}

def mergeIndexTypeTable(ddbTableName,tableConfig,mutable invalidIndex2MsgTable,indexTypeTableArray){
	if(indexTypeTableArray.isVoid()){
		return NULL,NULL;
	}
	index=array(INT);
	type=array(CHAR);
	ddbTable=NULL;
	for(indexTypeDict in indexTypeTableArray){
		try{
			type.append!(indexTypeDict.type);
			index.append!(indexTypeDict.index);
			if(ddbTable.isVoid()){
				ddbTable=indexTypeDict.ddbTable;
			}else{
				size=ddbTable.tableInsert(indexTypeDict.ddbTable);
				if(size!=indexTypeDict.ddbTable.size()){
					msg=ddbTableName+" mergeIndexTypeTable 合并表的数据不匹配，"+string(size)+" mismatch "+string(indexTypeDict.ddbTable.size());
					//invalidIndex2MsgTable[index]=msg;
					setTableErrorMsg(invalidIndex2MsgTable,index,ddbTableName,"process",msg);
					writeError(msg);
					continue;
				}
			}
		}catch(ex){
			msg=ddbTableName+" mergeIndexTypeTable error: "+obj2str(ex);
			//invalidIndex2MsgTable[indexTypeDict.index]=msg;
			setTableErrorMsg(invalidIndex2MsgTable,indexTypeDict.index,ddbTableName,"process",msg);
			writeError(msg);
		}
	}
	if(index.size()<1)
		return NULL,NULL;
	//重命名
	diff=ddbTable.cols()-tableConfig.schema.rows();
	if(diff > 0){
		msg=ddbTableName+" mergeIndexTypeTable 表的列数与ddb表不匹配，"+string(ddbTable.cols())+" mismatch "+string(tableConfig.schema.rows());
		//invalidIndex2MsgTable[index]=msg;
		setTableErrorMsg(invalidIndex2MsgTable,index,ddbTableName,"process",msg);
		writeError(msg);
		return NULL,NULL;
	}
	ddbTable.rename!(tableConfig.schema.name[0:ddbTable.cols()]);
	indexTypeTable=table(1:0,["index","type","indexInTableIndex"],[INT,CHAR,INT]);
	size=indexTypeTable.tableInsert(index,type,0..(index.size()-1));
	if(size!=index.size()){
		msg=ddbTableName+" mergeIndexTypeTable 插入数据条数不匹配，"+string(size)+" mismatch "+string(index.size());
		//invalidIndex2MsgTable[index]=msg;
		setTableErrorMsg(invalidIndex2MsgTable,index,ddbTableName,"process",msg);
		writeError(msg);
		return NULL,NULL;
	}
	return indexTypeTable,ddbTable;
}

def processByTable(index2DataDict,index2BeforedataDict,mutable invalidIndex2MsgTable,ddbTableDict){
	processSum=0;
	lastDdbTableName="";
	stage="";
	for(ddbTableName in index2DataDict.keys()){
		ddbTable=NULL;
		try{
			tableConfig=ddbTableDict[ddbTableName];
			tableHandle=loadTable(tableConfig.dbName,tableConfig.tbName);
			stage="mergeIndexTypeTable data";
			indexTypeTable,ddbTable=mergeIndexTypeTable(ddbTableName,tableConfig,invalidIndex2MsgTable,index2DataDict[ddbTableName]);
			if(indexTypeTable.isVoid()==false){
    			stage="mergeIndexTypeTable beforeData";
				indexTypeTableBefore,ddbTableBefore=mergeIndexTypeTable(ddbTableName,tableConfig,invalidIndex2MsgTable,index2BeforedataDict[ddbTableName]);
				index2indexintableDictBefore=dict(INT,INT);
				if(indexTypeTableBefore.isVoid()==false)
					index2indexintableDictBefore[indexTypeTableBefore.index]=indexTypeTableBefore.indexInTableIndex;
				indexTypeTable.sortBy!("index");
				indexTypeTableSegment=select *,segmentby(cumfirstNot,index,type) as indexType from indexTypeTable;
				lastOpData=array(ANY);
				stage="processDataIndex data";
				resultTable=select processDataIndex(tableConfig,tableHandle,ddbTable,ddbTableBefore,index2indexintableDictBefore,
										invalidIndex2MsgTable,lastOpData,first(type),
										index,indexInTableIndex) as count from indexTypeTableSegment group by indexType;
				stage="processDataIndex beforeData";
				addTableOp(lastOpData,tableHandle,invalidIndex2MsgTable,tableConfig);
				curSum=sum(resultTable.count);
				if(curSum>0){
					lastDdbTableName=ddbTableName;
					processSum+=curSum;
				}
			}
		}catch(ex){
			writeError(ddbTableName+" processByTable in "+stage+" error: "+obj2str(ex),ddbTable);
		}
	}
	return lastDdbTableName,processSum;
}

def getConfigDict(streamName){
	return objByName(streamName+"_cfg");
}

def dropExpiredErrorInfoPartitions(monthDuration){
	partis=NULL;
	try{
		partis=exec distinct(dfsPath.split("/")[2]) from getTabletsMeta("/FlinkcdcSysInfo/%","ErrorInfo",,-1)
		db=database("dfs://FlinkcdcSysInfo");
		minMonth=month(temporalAdd(now(),-monthDuration,"M"));
		delMonth=array(MONTH);
		for(partStr in partis){
			partiM=temporalParse(partStr.left(6),"yyyyMM");
			if(partiM<minMonth){
				db.dropPartition(partiM,"ErrorInfo",true,true);
				delMonth.append!(partiM);
			}
		}
		writeError("dropExpiredErrorInfoPartitions "+string(delMonth)+" done.");
	}catch(ex){
		writeError("dropExpiredErrorInfoPartitions failed, "+string(partis)+" error "+string(ex));
	}
}

def processMsg(streamName,msg,saveLastPos=false,threadId=0){
	writeLog("FKCDC start size "+msg.size()+" saveLastPos "+string(saveLastPos));
	startTime=now(true);
	dataSum=0;
	processSum=0;
	lastDdbTableName="";
	otherMsg="";
	data2DdbTime=0;
	processDdbTime=0;
	if(msg.size()>0){
		configDict=NULL;
		try{
			configDict=getConfigDict(streamName);
		}catch(ex){
			writeError("FKCDC end with error: process is stopped.");
			return;
		}
		invalidIndex2MsgTable=keyedTable(["index","table"], 1000:0, ["index","table","type","msg","time"], [INT,SYMBOL,SYMBOL,SYMBOL,NANOTIMESTAMP]);
		varNameofInvalidIndex2MsgTable=streamName+"_invalidIndex2MsgTable_"+string(threadId);
		if(defined(varNameofInvalidIndex2MsgTable,SHARED)){
			undef(varNameofInvalidIndex2MsgTable,SHARED);
		}
		//share to modify it in multithread, or it will cause crash! 
		share(invalidIndex2MsgTable,varNameofInvalidIndex2MsgTable);
		try{
			stage="data2Ddbtable";
			indexMsg=select rowNo(type) as index,* from msg;

			index2DataDict=dict(STRING,ANY);//data table
			index2BeforedataDict=dict(STRING,ANY);//beforeData table

			sourceResult=select data2Ddbtable(configDict.sourceTable[last(sourceTable)],configDict.ddbTable,last(tables),index2DataDict,index2BeforedataDict,invalidIndex2MsgTable,index,type,data,beforeData) as count
				from indexMsg group by sourceTable;
			data2DdbTime=(now(true)-startTime)/1000000;
			dataSum=sum(sourceResult.count);
			
			stage="processData";
			lastDdbTableName,processSum=processByTable(index2DataDict,index2BeforedataDict,invalidIndex2MsgTable,configDict.ddbTable);
			processDdbTime=(now(true)-startTime-data2DdbTime)/1000000;
		}catch(ex){
			writeError("processMsg failed in "+stage+" with error "+obj2str(ex));
		}
		if(invalidIndex2MsgTable.size()>0){
			try{
				stage="selectInvalidMsg";
				errorMsgs=select indexMsg.*,
					streamName,
					invalidIndex2MsgTable.table as errorTable,invalidIndex2MsgTable.time as errorTime,
					"<"+invalidIndex2MsgTable.type+"> "+invalidIndex2MsgTable.msg as errorMsg from ej(indexMsg,invalidIndex2MsgTable,"index");
				errorMsgs.dropColumns!("index");
				errorMsgs.addColumn(["retryTime"],[NANOTIMESTAMP]);
				size=objByName(configDict.errorStreamTableName).tableInsert(errorMsgs);
				if(size!=errorMsgs.size()){
					writeError("processMsg failed at tableInsert error, "+string(size)+" mismatch "+string(errorMsgs.size()),errorMsgs);
				}
				if(now()>configDict.dropErrorInfoNextTime){
					dropExpiredErrorInfoPartitions(configDict.errorInfoRetentionMonths);
					configDict["dropErrorInfoNextTime"]=timestamp(temporalAdd(monthBegin(now()),1,"M"));
				}
			}catch(ex){
				writeError("processMsg failed in "+stage+" with error "+obj2str(ex));
			}
		}
		if(saveLastPos){
			try{
				stage="saveLastPos";
				lastFilePosDict=dict(STRING,ANY);
				lastFilePosDict["file"]=msg.file[msg.size()-1];
				lastFilePosDict["pos"]=msg.pos[msg.size()-1];
				configDict["lastFilePos"]=lastFilePosDict;
				otherMsg=" lastFilePos "+msg.file[msg.size()-1]+" "+msg.pos[msg.size()-1];
			}catch(ex){
				writeError("processMsg error in "+stage+" with error "+obj2str(ex));
			}
		}
		undef(varNameofInvalidIndex2MsgTable,SHARED);
	}
	costTime=(now(true)-startTime)/1000000;
	writeLog("FKCDC end size "+string(msg.size())+" saveLastPos "+string(saveLastPos)+" time "+string(costTime)+"="+string(data2DdbTime)+"+"+string(processDdbTime)+"ms dataSum "+string(dataSum)+" processSum "+string(processSum)+" last "+lastDdbTableName + otherMsg);
}

def getLastFilePos(streamName){
	try{
		ksTable=objByName(streamName);
		if(isVoid(ksTable)==false){
			lastFilePos=select file,pos from objByName(streamName) order by file,pos desc limit 1;
			if(lastFilePos.size()>0)
				return lastFilePos;
		}
	}catch(ex){
		writeError("getLastFilePos get stream error "+string(ex));
	}
	try{
	    streamNameValue=streamName;
		lastFilePos=select file,pos from loadTable("dfs://FlinkcdcSysInfo","LastFilePos") where streamName=streamNameValue order by time desc limit 1;
		if(lastFilePos.size()>0)
			return lastFilePos;
	}catch(ex){
		writeError("getLastFilePos query file error "+string(ex));
	}
	return NULL;
}

def sourcesTable2Tables(streamName){
	configDict=getConfigDict(streamName);
	source2TablesDict=dict(STRING,STRING);
	for(sourceTableName in configDict.sourceTable.keys()){
		sourceTableCfg=configDict.sourceTable[sourceTableName];
		source2TablesDict[sourceTableName]=concat(sourceTableCfg.table.keys(),",");
	}
	return source2TablesDict;
}

def isRunning(streamName){
	try{
		getConfigDict(streamName);
		objByName(streamName);
		return sourcesTable2Tables(streamName);
	}catch(ex){
		return NULL;
	}
}

def saveLastFilePos(streamName,lastFilePos){
	dbPath="dfs://FlinkcdcSysInfo";
	//dropDB(dbPath);
	saveTableName="LastFilePos";
	//dropTable(database(dbPath),saveTableName);
	if(existsTable(dbPath,saveTableName)==false){
		dt=table(1:0,["streamName","file","pos","time"],[SYMBOL,SYMBOL,STRING,TIMESTAMP]);
		tb=createPartitionedTable(database(dbPath),dt,saveTableName,"time",,["streamName"]);
	}else{
		tb=loadTable(database(dbPath),saveTableName);
	}
	data=table(streamName as c1,lastFilePos.file as c2,lastFilePos.pos as c3,now() as c4);
	tb.upsert!(data,keyColNames="streamName");
}

def getQueueDepth(streamName){
	try{
		ksTable=objByName(streamName);
	}catch(ex){
		return;
	}
	if(isVoid(ksTable))
		throw "No stream table, please call start for "+streamName;
	sTableNames=[streamName];
	try{
		configDict=getConfigDict(streamName);
		if(configDict.errorStreamTableName.isVoid()==false){
			sTableNames.append!(configDict.errorStreamTableName);
		}
	}catch(ex){}
	topics=select tableName,"%/"+streamName+"/"+actions as topic from getStreamingStat().pubTables where tableName in sTableNames;
	getMaxQueueDepth=def(subWorkers,topic){
		whereCode=expr(sqlCol("topic"),like,topic);
		return long(sum(sql(sqlCol("queueDepth"),subWorkers,whereCode).eval().queueDepth));
	}
	queueDepth=each(getMaxQueueDepth{getStreamingStat().subWorkers},topics.topic);
	return table(topics.tableName,queueDepth);
}

def stop(streamName,needDropStreamTable=false){
	//query stream table
	try{
		ksTable=objByName(streamName);
	}catch(ex){
		//no stream table, do nothing
		return;
	}
	if(isVoid(ksTable))
		throw "No stream table, please call start with "+streamName;
	//unsubscribeTable all
	try{
		actionNames=exec actions from getStreamingStat().pubTables where tableName=streamName;
		if(actionNames.size()>0)
			loop(unsubscribeTable{"",streamName},actionNames);
	}catch(ex){
		writeError("stop unsubscribeTable "+streamName+" error: "+obj2str(ex));
	}
	configDict=NULL;
	try{
		configDict=getConfigDict(streamName);
	}catch(ex){}
	if(configDict.isVoid()==false){
		//save last file pos
		try{
			if(configDict.lastFilePos.count()>0)
				saveLastFilePos(streamName,configDict.lastFilePos);
		}catch(ex){
			writeError("stop saveLastFilePos "+streamName+" error: "+obj2str(ex));
		}
		if(configDict.errorStreamTableName.isVoid()==false){
			//drop error stream table
			try{
				actionNames=exec actions from getStreamingStat().pubTables where tableName=configDict.errorStreamTableName;
				if(actionNames.size()>0)
					loop(unsubscribeTable{"",configDict.errorStreamTableName},actionNames);
			}catch(ex){
				writeError("stop unsubscribeTable "+configDict.errorStreamTableName+" error: "+obj2str(ex));
			}
			if(needDropStreamTable){
				try{
					dropStreamTable(configDict.errorStreamTableName);
				}catch(ex){
					writeError("stop dropStreamTable "+configDict.errorStreamTableName+" error: "+obj2str(ex));
				}
			}
		}
		undef(streamName+"_cfg",SHARED);
	}
	if(needDropStreamTable){
		dropStreamTable(streamName);
	}
}

def trucateTables(streamName){
	stage="prepare";
	try{
		stage="findObject "+streamName;
		configDict=getConfigDict(streamName);
		tableDict=configDict.ddbTable;
		if(tableDict.isVoid())
			throw "No table config";
		for(tbName in tableDict.keys()){
			stage="findTableObject "+tbName;
			tbConfigDict=tableDict[tbName];
			if(tbConfigDict.isVoid()==false){
				stage="truncate";
				times=0;
				do{
				    try{
				        times+=1;
    				    truncate(tbConfigDict.dbName,tbConfigDict.tbName);
						break;
    				}catch(ex){
        				msg=obj2str(ex);
    				    if(times>10||isInTransation(msg)==false){
							writeError("truncate "+tbConfigDict.dbName+"/"+tbConfigDict.tbName+" error "+msg);
    				        break;
						}
    				}
    			}while(true);
			}else{
				throw "invalid config";
			}
		}
	}catch(ex){
		throw "trucateTables in "+stage+" error "+obj2str(ex);
	}
}

def getConfigValue(config,key,defaultValue){
	if(config[key].isVoid()==false)
		return config[key];
	else
		return defaultValue;
}

def prepareConfigForDdbTable(mutable transformDict,mutable ddbTableDict,sourceTableName,tbConfig){
	ddbTableName=tbConfig.name;
	if(isVoid(ddbTableName))
		throw sourceTableName+"的name不能为空";
	if(transformDict[ddbTableName].isVoid()==false){//重复添加
		throw sourceTableName+"的"+ddbTableName+"重复添加";
	}
	tableTransformDict=dict(STRING,ANY);
	if(isVoid(tbConfig.transform)==false){
		if(strlen(tbConfig.transform)>0){
			try{
				transformFunc=funcByName(tbConfig.transform);
			}catch(ex){
				throw sourceTableName+"到"+ddbTableName+"找不到transform函数"+tbConfig.transform;
			}
			tableTransformDict["transform"]=transformFunc;
		}
	}
	transformDict[ddbTableName]=tableTransformDict;
	//后面的都是和数据处理相关的操作
	tbConfigDict=ddbTableDict[ddbTableName];
	if(tbConfigDict.isVoid()){
		splashfields=ddbTableName.split("/");
		if(splashfields.size()<1) throw ddbTableName+"不是一个数据库表名，类似：dfs://db1/tb1";
		dbname=concat(splashfields[0:(splashfields.size()-1)],"/")
		tbname=splashfields[splashfields.size()-1];
		try{
			tableHandle=loadTable(dbname,tbname);
		}catch(ex){
			throw sourceTableName+"的"+ddbTableName+"指向的库表不存在，"+obj2str(ex);
		}
		tbConfigDict=dict(STRING,ANY);
		tbConfigDict["name"]=ddbTableName;
		tbConfigDict["dbName"]=dbname;
		tbConfigDict["tbName"]=tbname;
		tableSchema=tableHandle.schema();
		schema=table(tableSchema.colDefs.name as name,tableSchema.colDefs.typeInt as type);
		tbConfigDict["schema"]=schema;
		if(sum(tableSchema.partitionColumnIndex>=0)>0){
			tbConfigDict["parCols"]=tableSchema.partitionColumnName;
			tbConfigDict["parTypes"]=tableSchema.partitionTypeName;
			tbConfigDict["parSchemas"]=tableSchema.partitionSchema;
		}else{
			tbConfigDict["parCols"]=NULL;
			tbConfigDict["parTypes"]=NULL;
			tbConfigDict["parSchemas"]=NULL;
		}
		//为了加快搜索，分区字段优先，排序字段次之，普通字段最后的顺序排列字段
		colTable=table(tableSchema.colDefs.name as name,0..(tableSchema.colDefs.size()-1) as index,tableSchema.colDefs.typeInt as type,take(0,tableSchema.colDefs.size()) as pri);
		if(tableSchema.sortColumns.size()>0)
			update colTable set pri=1 where name in tableSchema.sortColumns;
		if(tableSchema.partitionColumnName.size()>0)
			update colTable set pri=2 where name in tableSchema.partitionColumnName;
		//获取分区列和排序列，用于update时判断是否需要删除旧元素
		tbConfigDict["keyCols"]=exec name from colTable where pri>=1;
		if(isVoid(tbConfig.delField)==false){//soft delete
			if(tbConfig.uniqueColumn.isVoid()==false){//用户设置了唯一键，冲突
				throw sourceTableName+"到"+ddbTableName+"的delField和uniqueColumn字段不能同时设置";
			}
			delField=tbConfig.delField;
			if(delField.name.isVoid()){
				throw sourceTableName+"到"+ddbTableName+"的delField字段没有name字段";
			}
			typeInts=exec typeInt from tableSchema.colDefs where name=delField.name;
			if(typeInts.size()!=1){
				throw sourceTableName+"到"+ddbTableName+"的delField字段"+delField.name+"个数"+string(typeInts.size())+"不等于1";
			}
			if(delField.value.size()!=2){
				throw sourceTableName+"到"+ddbTableName+"有delField但value没有两个值"+obj2str(delField.value);
			}
			typeInt=typeInts[0];
			try{
				delFieldDict=dict(STRING,ANY);
				delFieldDict["value"]=each(cast{,typeInt},delField.value);
				delFieldDict["name"]=delField.name;
				tbConfigDict["delFieldDict"]=delFieldDict;
			}catch(ex){
				throw sourceTableName+"到"+ddbTableName+"的两个值"+obj2str(delField.value)+"无法转换为"+delField.name+"字段，请检查后重试";
			}
		}else{
			if(tbConfig.uniqueColumn.isVoid()){
				throw sourceTableName+"到"+ddbTableName+"的delField和uniqueColumn字段必须要设置一个";
			}
			uniqueColumnTable=colTable;
			if(tbConfig.uniqueColumn.size()==0)
				throw sourceTableName+"到"+ddbTableName+"的uniqueColumn没有包含字段";
			delete from uniqueColumnTable where name not in tbConfig.uniqueColumn;
			if(uniqueColumnTable.size() != tbConfig.uniqueColumn.size())
				throw sourceTableName+"到"+ddbTableName+"的uniqueColumn字段在表中没有对应的字段，预期"+string(tbConfig.uniqueColumn.size())+"，实际"+string(uniqueColumnTable.size());
			tbConfigDict["uniqueColumns"]=select name,index from uniqueColumnTable order by pri desc;
		}
		tbConfigDict["attributeJson"]=toStdJson((tbConfig.delField,tbConfig.uniqueColumn));
		ddbTableDict[ddbTableName]=tbConfigDict;
	}else{
		curAttributeJson=toStdJson((tbConfig.delField,tbConfig.uniqueColumn));
		if(tbConfigDict.attributeJson!=curAttributeJson)
			throw sourceTableName+"的"+ddbTableName+"的delField,uniqueColumn属性 "+curAttributeJson+"和上次的不一样"+tbConfigDict.attributeJson;
	}
}

//sourceTableDict：sourceTable->schema,transform,table
//tableDict: table->schema,tableHandle,delField,delValues,parCols,keyCols
def prepareConfigForSourceTable(mutable sourceTableDict,mutable ddbTableDict,stConfig){
	// stConfig=tbconfig.sourceTable[0]
	// streamName=tbconfig.table
	sourceTableName=stConfig.name;
	if(isVoid(sourceTableName))
		throw "sourceTable的name不能为空";
	if(isVoid(sourceTableDict[sourceTableName])==false){
		throw sourceTableName+"重复添加";
	}
	stConfigDict=dict(STRING,ANY);
	stConfigDict["name"]=sourceTableName;
	if(isVoid(stConfig.schema)==false){
		//字符串转为int类型
		try{
			name=array(STRING);
			type=array(STRING);
			typeInt=array(INT);
			addNameType=def(mutable nameArray,mutable typeArray,mutable typeIntArray,nameType){
				if(isVoid(nameType.name)){
					throw "schema中必须有name";
				}
				if(isVoid(nameType.type)){
					throw "schema中"+nameType.name+"没有type";
				}
				nameArray.append!(nameType.name);
				typeArray.append!(nameType.type);
				try{
					typeIntArray.append!(parseExpr(nameType.type).eval());
				}catch(ex){
					throw "schema中"+nameType.name+"type错误"+string(ex);
				}
				return 1;
			}
			loop(addNameType{name,type,typeInt},stConfig.schema);
			stConfigDict["schema"]=table(name,type,typeInt);
		}catch(ex){
			throw sourceTableName+"转换出错"+obj2str(type);
		}
	}else{
		stConfigDict["schema"]=NULL;
	}
	transformDict=dict(STRING,ANY);
	loop(prepareConfigForDdbTable{transformDict,ddbTableDict,sourceTableName},stConfig.ddbTable);
	stConfigDict["table"]=transformDict;
	
	sourceTableDict[sourceTableName]=stConfigDict;
}

def createErrorTable(streamName){
	errorStreamTableName=streamName+"ErrorStream";
	//t=table(1..100 as id);
	//coldefs=t.schema().colDefs
	coldefs=objByName(streamName).schema().colDefs;
	colNames=coldefs.name join ["streamName","errorTable","errorTime","errorMsg","retryTime"];
	colTypes=coldefs.typeInt join [SYMBOL,SYMBOL,NANOTIMESTAMP,STRING,NANOTIMESTAMP];
	dbPath="dfs://FlinkcdcSysInfo";
	tbName="ErrorInfo";
	if(existsDatabase(dbPath)) db=database(dbPath);
	else{
		db=database(dbPath,VALUE,[2023.01M],,"TSDB");
	}
	//dropTable(database(dbPath),tbName);
	if(existsTable(dbPath,tbName)==false){
		dt=table(1:0,colNames,colTypes);
		tbHandle=createPartitionedTable(database(dbPath),dt,tbName,"errorTime",,["streamName","sourceTable","errorTable","errorTime"],LAST,
																				[hashBucket{,3},hashBucket{,10},hashBucket{,10}]);
	}else{
		tbHandle=loadTable(dbPath,tbName);
	}
	if(defined(errorStreamTableName,SHARED)==false){
		errorSt=streamTable(1:0,colNames,colTypes);
		enableTableShareAndPersistence(errorSt,errorStreamTableName,true,true,1000,7200,0,1000);
		go;
	}
	return tbHandle,errorStreamTableName;
}

//根据streamName创建FlinkCDC需要的流表，返回config中支持的表名
def start(streamName, configText,needDropStreamTable=false){
	//check if last stream table exist.
	isLastStreamTableValid=defined(streamName,SHARED);
	//stop last
	stop(streamName,false);
	try{
		config=parseExpr(configText).eval();
	}catch(ex){
		throw "config不是有效的JSON文件";
	}
	if(config.sourceTable.isVoid()){
		throw "config没有包含sourceTable字段";
	}
	sourceTableDict=dict(STRING,ANY);
	ddbTableDict=dict(STRING,ANY);
	loop(prepareConfigForSourceTable{sourceTableDict,ddbTableDict},config.sourceTable);
	if(sourceTableDict.size()<1){
		throw "config中没有包含任何有效的表";
	}
	try{
		stage="createStreamTable";
		eConfig=config.enableTableShareAndPersistence;
		if(isLastStreamTableValid==false){
			ksTable=keyedStreamTable(["file","pos"],(eConfig.cacheSize):0,["file","pos","time","type","sourceTable","tables","data","beforeData"],[SYMBOL,STRING,NANOTIMESTAMP,CHAR,SYMBOL,SYMBOL,BLOB,BLOB]);
			setStreamTableFilterColumn(ksTable,"sourceTable");
			enableTableShareAndPersistence(ksTable,streamName,eConfig.asynWrite,true,eConfig.cacheSize,eConfig.retentionMinutes,eConfig.flushMode,eConfig.cacheSize);
			go;
			if(needDropStreamTable){
				colDefs=ksTable.schema().colDefs;
				dropStreamTable(streamName);
				ksTable=keyedStreamTable(["file","pos"],(eConfig.cacheSize):0,colDefs.name,colDefs.typeInt);
				setStreamTableFilterColumn(ksTable,"sourceTable");
				enableTableShareAndPersistence(ksTable,streamName,eConfig.asynWrite,true,eConfig.cacheSize,eConfig.retentionMinutes,eConfig.flushMode,eConfig.cacheSize);
				go;
			}
		}
		stage="createErrorStreamTable";
		errorTbHandle,errorStreamTableName=createErrorTable(streamName);
		
		configDict=syncDict(STRING,ANY,streamName+"_cfg");
		configDict["sourceTable"]=sourceTableDict;
		configDict["ddbTable"]=ddbTableDict;
		configDict["errorStreamTableName"]=errorStreamTableName;
		configDict["errorInfoRetentionMonths"]=getConfigValue(config,"errorInfoRetentionMonths",1);

		stage="subscribeTableStreamTable";
		subscribeTable(,errorStreamTableName,errorStreamTableName,-2,errorTbHandle,true,100000,60);
		sConfig=config.subscribeTable;
		subThreadCount=min(sConfig.threadCount,sourceTableDict.size());
		if(subThreadCount > 1){
			for(filterIndex in 0..(subThreadCount-1)){
				actionName=streamName+string(filterIndex);
				subscribeTable(,streamName,actionName,-2,processMsg{streamName,,true,filterIndex},true,sConfig.batchSize,sConfig.throttle,-2,true,(subThreadCount,filterIndex),true);
			}
		}else{
			subscribeTable(,streamName,streamName,-2,processMsg{streamName,,true,0},true,sConfig.batchSize,sConfig.throttle,-2,true,,true);
		}
		stage="sourcesTable2Tables";
		return sourcesTable2Tables(streamName);
	}catch(ex){
		try{
			if(isLastStreamTableValid){
				//don't drop stream table
				stop(streamName,false);
			}else{
				//drop stream table
				stop(streamName,true);
			}
		}catch(ex2){}
		throw "start failed in "+stage+" error: "+obj2str(ex);
	}
}

def processErrorMsg(streamName,batchSize,whereCodeOrTable=NULL){
	//if it is processing
	if(batchSize < 100)
		throw "batchSize must be greater than 100";
	try{
		configDict=getConfigDict(streamName);
		colNames=objByName(streamName).schema().colDefs.name;
	}catch(ex){
		throw "processErrorMsg error: "+obj2str(ex)+", please call start first.";
	}
	try{
		dbPath="dfs://FlinkcdcSysInfo";
		tbName="ErrorInfo";
		tbHandle=loadTable(dbPath,tbName);
		if(whereCodeOrTable.isVoid()==false){
			if(whereCodeOrTable.form()==TABLE)
				retryTable=whereCodeOrTable;
			else
				retryTable=sql(sqlCol("*"),tbHandle,where=whereCodeOrTable).eval();
		}else
			retryTable=sql(sqlCol("*"),tbHandle).eval();
		if(retryTable.size()<1)
			return 0;
		if(retryTable.size()>batchSize)
			batchIndexArray=cut(0..(retryTable.size()-1),batchSize);
		else
			batchIndexArray=[0..(retryTable.size()-1)];
		for(indexArray in batchIndexArray){
			subRetryTable=retryTable[indexArray];
			subRetryTable["retryTime"]=now(true);
			size=tbHandle.tableInsert(subRetryTable);
			if(size!=subRetryTable.size()){
				throw "processErrorMsg update "+tbName+" error, "+string(size)+" mismatch "+string(subRetryTable.size());
			}
			subRetryTable["tables"]=subRetryTable.errorTable;
			msgTable=table(subRetryTable[colNames]);
			msgTable.rename!(colNames);
			processMsg(streamName,msgTable);
		}
		return retryTable.size();
	}catch(ex){
		msg=streamName+" processErrorMsg batchSize "+string(batchSize)+" whereCodeOrTable "+obj2str(whereCodeOrTable)+" error: "+obj2str(ex);
		writeError(msg);
		throw msg;
	}
}
// def addErrorMsg(streamName,data,errorMsg,errorTables){
// 	if(data.size()<1)
// 		return;
// 	if(errorMsg.isVoid()){
// 		throw "No errorMsg";
// 	}
// 	configDict=getConfigDict(streamName);
// 	//errorTable","errorTime","errorMsg","retryTime"
// 	errorData=data;
// 	errorData.update!("errorTable",iif(errorTables.isVoid(),data.tables,errorTables));
// 	errorData.update!("errorTime",now(true));
// 	errorData.update!("errorMsg",errorMsg);
// 	errorData.update!("retryTime",nanotimestamp(NULL));
// 	size=objByName(configDict.errorStreamTableName).tableInsert(errorData);
// 	if(size!=errorData.size()){
// 		throw "addErrorMsg failed at errorStreamTableName tableInsert, "+string(size)+" mismatch "+string(errorData.size());
// 	}
// }

// streamName="FlinkCDCStreamTable";
// stop(streamName,true);
//sourcesTableList2OutputDict(streamName);
//trucateTables(streamName);

// def toFactor(mutable tb){
//     TradeTImeA=timestamp(tb.TradeTIme);
//     ReceiveTimeA=time(tb.ReceiveTime);
//     tb.replaceColumn!(`TradeTIme,TradeTImeA);
//     tb.replaceColumn!(`ReceiveTime,ReceiveTimeA);
//     return tb;
// }
// streamName="FlinkCDCStreamTable";
// f=file("flinkcdc.cfg");
// configTextLines=readLines(f,4096);
// configText=concat(configTextLines);
// //stop(streamName);
// start(streamName,configText);
// print("OK");

// streamName="FlinkCDCStreamTable";
// processErrorMsg(streamName,10000,<errorTime>=2023.09.27T11:59:09>);

// streamName="FlinkCDCStreamTable";
// print(getQueueDepth(streamName));

// streamName="FlinkCDCStreamTable";
// f=file("transform.dos");
// lines=readLines(f,4096);
// transform=concat(lines);
// runScript(transform);
// f=file("table_entrust.cfg");
// lines=readLines(f,4096);
// trimremark=def(text){
// 	trimtext=trim(text);
// 	if(trimtext.strlen()==0) return "";
// 	if(trimtext[0]=='#') return "";
// 	return trimtext;
// }
// trimlines=each(trimremark,lines);
// configText=concat(trimlines);
// //stop(streamName);
// start(streamName,configText);
// f=file("baddata.json");
// lines=readLines(f,4096);
// msgdata=concat(lines);
// schema=table(["file","pos","time","type","sourceTable","tables","data","beforeData"] as name,["SYMBOL","STRING","NANOTIMESTAMP","CHAR","SYMBOL","SYMBOL","STRING","STRING"] as type);
// msg=parseJsonTable(msgdata,schema)
// processMsg(streamName,msg);

// streamName="FlinkCDCStreamTable";
// msg=select top 10000 * from objByName(streamName) where type !='c';
// processMsg(streamName,msg);
